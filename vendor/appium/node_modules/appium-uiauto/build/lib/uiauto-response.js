'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var MESSAGE_TYPES = ['error', 'no data', 'regular', 'chunk', 'last chunk'];

var UNKNOWN_ERROR = {
  status: 13,
  value: 'Error parsing socket data from instruments'
};

/*
 * Object to contain the data received from the UI Automation system.
 */

var UIAutoResponse = (function () {
  function UIAutoResponse() {
    _classCallCheck(this, UIAutoResponse);

    this.bufferedData = '';
    this.resultBuffer = '';
  }

  _createClass(UIAutoResponse, [{
    key: 'resetBuffer',
    value: function resetBuffer() {
      this.bufferedData = '';
    }
  }, {
    key: 'addData',
    value: function addData(data) {
      this.bufferedData += data;
    }
  }, {
    key: 'finalizeData',
    value: function finalizeData() {
      var data = this.bufferedData;
      this.bufferedData = '';

      // try to figure out what type of data we have, and return it
      var parsedData = undefined;
      try {
        parsedData = {
          type: MESSAGE_TYPES[parseInt(data[0], 10)]
        };
        if (parsedData.type !== 'no data') {
          // format is <one char message type>,<DATA>
          parsedData.result = data.substring(2);
        }
      } catch (err) {
        _logger2['default'].error('Could not parse data from socket: ' + err);
        _logger2['default'].error(data);
        parsedData = {
          type: 'error',
          error: UNKNOWN_ERROR
        };
      }

      return parsedData;
    }
  }, {
    key: 'getResult',
    value: function getResult() {
      var data = this.finalizeData();

      if (!_lodash2['default'].isUndefined(data.result) && data.result !== false) {
        // we have a result, try to make use of it
        if (data.result) {
          _logger2['default'].debug('Got result from instruments: ' + data.result.slice(0, 300));
        } else {
          _logger2['default'].debug('Got null result from instruments');
        }

        if (data.type && data.type.indexOf('chunk') !== -1) {
          // a "chunk" of data, so add to our buffer
          this.resultBuffer += data.result;
          _logger2['default'].debug('Got chunk data, current resultBuffer length: ' + this.resultBuffer.length);
          if (data.type === 'last chunk') {
            _logger2['default'].debug('This is the last data final length: ' + this.resultBuffer.length);
            // this is the last row, unpack and return response
            var result = undefined;
            try {
              result = JSON.parse(this.resultBuffer);
            } catch (err) {
              _logger2['default'].error('Could not parse result buffer: ' + err);
              result = UNKNOWN_ERROR;
            }
            this.resultBuffer = '';
            return result;
          } else {
            _logger2['default'].debug('Not the last chunk, trying to get more');
            return {
              needsMoreData: true
            };
          }
        } else {
          // not a "chunk", so parse and return
          var result = undefined;
          try {
            result = JSON.parse(data.result);
          } catch (err) {
            _logger2['default'].error('Could not parse result buffer: ' + err);
            result = UNKNOWN_ERROR;
          }
          return result;
        }
      } else {
        // we have no result
        return null;
      }
    }
  }]);

  return UIAutoResponse;
})();

exports['default'] = UIAutoResponse;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91aWF1dG8tcmVzcG9uc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3NCQUFnQixVQUFVOzs7O3NCQUNaLFFBQVE7Ozs7QUFFdEIsSUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7O0FBRTdFLElBQU0sYUFBYSxHQUFHO0FBQ3BCLFFBQU0sRUFBRSxFQUFFO0FBQ1YsT0FBSyxFQUFFLDRDQUE0QztDQUNwRCxDQUFDOzs7Ozs7SUFNSSxjQUFjO0FBQ04sV0FEUixjQUFjLEdBQ0g7MEJBRFgsY0FBYzs7QUFFaEIsUUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7QUFDdkIsUUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7R0FDeEI7O2VBSkcsY0FBYzs7V0FNTix1QkFBRztBQUNiLFVBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0tBQ3hCOzs7V0FFTyxpQkFBQyxJQUFJLEVBQUU7QUFDYixVQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQztLQUMzQjs7O1dBRVksd0JBQUc7QUFDZCxVQUFJLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO0FBQzdCLFVBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDOzs7QUFHdkIsVUFBSSxVQUFVLFlBQUEsQ0FBQztBQUNmLFVBQUk7QUFDRixrQkFBVSxHQUFHO0FBQ1gsY0FBSSxFQUFFLGFBQWEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzNDLENBQUM7QUFDRixZQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFOztBQUVqQyxvQkFBVSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3ZDO09BQ0YsQ0FBQyxPQUFPLEdBQUcsRUFBRTtBQUNaLDRCQUFJLEtBQUssd0NBQXNDLEdBQUcsQ0FBRyxDQUFDO0FBQ3RELDRCQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQixrQkFBVSxHQUFHO0FBQ1gsY0FBSSxFQUFFLE9BQU87QUFDYixlQUFLLEVBQUUsYUFBYTtTQUNyQixDQUFDO09BQ0g7O0FBRUQsYUFBTyxVQUFVLENBQUM7S0FDbkI7OztXQUVTLHFCQUFHO0FBQ1gsVUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDOztBQUUvQixVQUFJLENBQUMsb0JBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLEtBQUssRUFBRTs7QUFFeEQsWUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2YsOEJBQUksS0FBSyxtQ0FBaUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFHLENBQUM7U0FDeEUsTUFBTTtBQUNMLDhCQUFJLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1NBQy9DOztBQUVELFlBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTs7QUFFbEQsY0FBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ2pDLDhCQUFJLEtBQUssbURBQWlELElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFHLENBQUM7QUFDdEYsY0FBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksRUFBRTtBQUM5QixnQ0FBSSxLQUFLLDBDQUF3QyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBRyxDQUFDOztBQUU3RSxnQkFBSSxNQUFNLFlBQUEsQ0FBQztBQUNYLGdCQUFJO0FBQ0Ysb0JBQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUN4QyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ1osa0NBQUksS0FBSyxxQ0FBbUMsR0FBRyxDQUFHLENBQUM7QUFDbkQsb0JBQU0sR0FBRyxhQUFhLENBQUM7YUFDeEI7QUFDRCxnQkFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7QUFDdkIsbUJBQU8sTUFBTSxDQUFDO1dBQ2YsTUFBTTtBQUNMLGdDQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO0FBQ3BELG1CQUFPO0FBQ0wsMkJBQWEsRUFBRSxJQUFJO2FBQ3BCLENBQUM7V0FDSDtTQUNGLE1BQU07O0FBRUwsY0FBSSxNQUFNLFlBQUEsQ0FBQztBQUNYLGNBQUk7QUFDRixrQkFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1dBQ2xDLENBQUMsT0FBTyxHQUFHLEVBQUU7QUFDWixnQ0FBSSxLQUFLLHFDQUFtQyxHQUFHLENBQUcsQ0FBQztBQUNuRCxrQkFBTSxHQUFHLGFBQWEsQ0FBQztXQUN4QjtBQUNELGlCQUFPLE1BQU0sQ0FBQztTQUNmO09BQ0YsTUFBTTs7QUFFTCxlQUFPLElBQUksQ0FBQztPQUNiO0tBQ0Y7OztTQXhGRyxjQUFjOzs7cUJBMkZMLGNBQWMiLCJmaWxlIjoibGliL3VpYXV0by1yZXNwb25zZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgTUVTU0FHRV9UWVBFUyA9IFsnZXJyb3InLCAnbm8gZGF0YScsICdyZWd1bGFyJywgJ2NodW5rJywgJ2xhc3QgY2h1bmsnXTtcblxuY29uc3QgVU5LTk9XTl9FUlJPUiA9IHtcbiAgc3RhdHVzOiAxMyxcbiAgdmFsdWU6ICdFcnJvciBwYXJzaW5nIHNvY2tldCBkYXRhIGZyb20gaW5zdHJ1bWVudHMnXG59O1xuXG5cbi8qXG4gKiBPYmplY3QgdG8gY29udGFpbiB0aGUgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBVSSBBdXRvbWF0aW9uIHN5c3RlbS5cbiAqL1xuY2xhc3MgVUlBdXRvUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5idWZmZXJlZERhdGEgPSAnJztcbiAgICB0aGlzLnJlc3VsdEJ1ZmZlciA9ICcnO1xuICB9XG5cbiAgcmVzZXRCdWZmZXIgKCkge1xuICAgIHRoaXMuYnVmZmVyZWREYXRhID0gJyc7XG4gIH1cblxuICBhZGREYXRhIChkYXRhKSB7XG4gICAgdGhpcy5idWZmZXJlZERhdGEgKz0gZGF0YTtcbiAgfVxuXG4gIGZpbmFsaXplRGF0YSAoKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmJ1ZmZlcmVkRGF0YTtcbiAgICB0aGlzLmJ1ZmZlcmVkRGF0YSA9ICcnO1xuXG4gICAgLy8gdHJ5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0eXBlIG9mIGRhdGEgd2UgaGF2ZSwgYW5kIHJldHVybiBpdFxuICAgIGxldCBwYXJzZWREYXRhO1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWREYXRhID0ge1xuICAgICAgICB0eXBlOiBNRVNTQUdFX1RZUEVTW3BhcnNlSW50KGRhdGFbMF0sIDEwKV0sXG4gICAgICB9O1xuICAgICAgaWYgKHBhcnNlZERhdGEudHlwZSAhPT0gJ25vIGRhdGEnKSB7XG4gICAgICAgIC8vIGZvcm1hdCBpcyA8b25lIGNoYXIgbWVzc2FnZSB0eXBlPiw8REFUQT5cbiAgICAgICAgcGFyc2VkRGF0YS5yZXN1bHQgPSBkYXRhLnN1YnN0cmluZygyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihgQ291bGQgbm90IHBhcnNlIGRhdGEgZnJvbSBzb2NrZXQ6ICR7ZXJyfWApO1xuICAgICAgbG9nLmVycm9yKGRhdGEpO1xuICAgICAgcGFyc2VkRGF0YSA9IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3I6IFVOS05PV05fRVJST1JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gIH1cblxuICBnZXRSZXN1bHQgKCkge1xuICAgIGxldCBkYXRhID0gdGhpcy5maW5hbGl6ZURhdGEoKTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChkYXRhLnJlc3VsdCkgJiYgZGF0YS5yZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAvLyB3ZSBoYXZlIGEgcmVzdWx0LCB0cnkgdG8gbWFrZSB1c2Ugb2YgaXRcbiAgICAgIGlmIChkYXRhLnJlc3VsdCkge1xuICAgICAgICBsb2cuZGVidWcoYEdvdCByZXN1bHQgZnJvbSBpbnN0cnVtZW50czogJHtkYXRhLnJlc3VsdC5zbGljZSgwLCAzMDApfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nLmRlYnVnKCdHb3QgbnVsbCByZXN1bHQgZnJvbSBpbnN0cnVtZW50cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS50eXBlICYmIGRhdGEudHlwZS5pbmRleE9mKCdjaHVuaycpICE9PSAtMSkge1xuICAgICAgICAvLyBhIFwiY2h1bmtcIiBvZiBkYXRhLCBzbyBhZGQgdG8gb3VyIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlc3VsdEJ1ZmZlciArPSBkYXRhLnJlc3VsdDtcbiAgICAgICAgbG9nLmRlYnVnKGBHb3QgY2h1bmsgZGF0YSwgY3VycmVudCByZXN1bHRCdWZmZXIgbGVuZ3RoOiAke3RoaXMucmVzdWx0QnVmZmVyLmxlbmd0aH1gKTtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2xhc3QgY2h1bmsnKSB7XG4gICAgICAgICAgbG9nLmRlYnVnKGBUaGlzIGlzIHRoZSBsYXN0IGRhdGEgZmluYWwgbGVuZ3RoOiAke3RoaXMucmVzdWx0QnVmZmVyLmxlbmd0aH1gKTtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBsYXN0IHJvdywgdW5wYWNrIGFuZCByZXR1cm4gcmVzcG9uc2VcbiAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMucmVzdWx0QnVmZmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihgQ291bGQgbm90IHBhcnNlIHJlc3VsdCBidWZmZXI6ICR7ZXJyfWApO1xuICAgICAgICAgICAgcmVzdWx0ID0gVU5LTk9XTl9FUlJPUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZXN1bHRCdWZmZXIgPSAnJztcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy5kZWJ1ZygnTm90IHRoZSBsYXN0IGNodW5rLCB0cnlpbmcgdG8gZ2V0IG1vcmUnKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmVlZHNNb3JlRGF0YTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdCBhIFwiY2h1bmtcIiwgc28gcGFyc2UgYW5kIHJldHVyblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSByZXN1bHQgYnVmZmVyOiAke2Vycn1gKTtcbiAgICAgICAgICByZXN1bHQgPSBVTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGhhdmUgbm8gcmVzdWx0XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVUlBdXRvUmVzcG9uc2U7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
